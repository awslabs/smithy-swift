/*
 * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * SPDX-License-Identifier: Apache-2.0.
 */

package serde.xml

import MockHttpRestXMLProtocolGenerator
import TestContext
import defaultSettings
import getFileContents
import io.kotest.matchers.string.shouldContainOnlyOnce
import org.junit.jupiter.api.Test

class UnionEncodeXMLGenerationTests {
    @Test
    fun `001 XmlUnionShape+Codable`() {
        val context = setupTests("Isolated/Restxml/xml-unions.smithy", "aws.protocoltests.restxml#RestXml")
        val contents = getFileContents(context.manifest, "/RestXml/models/XmlUnionShape+Codable.swift")
        val expectedContents =
            """
// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension EventStreamTestClientTypes.TestStream: ClientRuntime.MessageMarshallable {
    public func marshall(encoder: ClientRuntime.RequestEncoder) throws -> ClientRuntime.EventStream.Message {
        var headers: [ClientRuntime.EventStream.Header] = [.init(name: ":message-type", value: .string("event"))]
        var payload: ClientRuntime.Data? = nil
        switch self {
        case .messagewithblob(let value):
            headers.append(.init(name: ":event-type", value: .string("MessageWithBlob")))
            headers.append(.init(name: ":content-type", value: .string("application/octet-stream")))
            payload = value.data
        case .messagewithstring(let value):
            headers.append(.init(name: ":event-type", value: .string("MessageWithString")))
            headers.append(.init(name: ":content-type", value: .string("text/plain")))
            payload = value.data?.data(using: .utf8)
        case .messagewithstruct(let value):
            headers.append(.init(name: ":event-type", value: .string("MessageWithStruct")))
            headers.append(.init(name: ":content-type", value: .string("application/json")))
            payload = try encoder.encode(value)
        case .messagewithunion(let value):
            headers.append(.init(name: ":event-type", value: .string("MessageWithUnion")))
            headers.append(.init(name: ":content-type", value: .string("application/json")))
            payload = try encoder.encode(value)
        case .messagewithheaders(let value):
            headers.append(.init(name: ":event-type", value: .string("MessageWithHeaders")))
            if let headerValue = value.blob {
                headers.append(.init(name: "blob", value: .data(headerValue)))
            }
            if let headerValue = value.boolean {
                headers.append(.init(name: "boolean", value: .bool(headerValue)))
            }
            if let headerValue = value.byte {
                headers.append(.init(name: "byte", value: .byte(headerValue)))
            }
            if let headerValue = value.int {
                headers.append(.init(name: "int", value: .int32(headerValue)))
            }
            if let headerValue = value.long {
                headers.append(.init(name: "long", value: .int64(headerValue)))
            }
            if let headerValue = value.short {
                headers.append(.init(name: "short", value: .int16(headerValue)))
            }
            if let headerValue = value.string {
                headers.append(.init(name: "string", value: .string(headerValue)))
            }
            if let headerValue = value.timestamp {
                headers.append(.init(name: "timestamp", value: .timestamp(headerValue)))
            }
        case .messagewithheaderandpayload(let value):
            headers.append(.init(name: ":event-type", value: .string("MessageWithHeaderAndPayload")))
            if let headerValue = value.header {
                headers.append(.init(name: "header", value: .string(headerValue)))
            }
            headers.append(.init(name: ":content-type", value: .string("application/octet-stream")))
            payload = value.payload
        case .messagewithnoheaderpayloadtraits(let value):
            headers.append(.init(name: ":event-type", value: .string("MessageWithNoHeaderPayloadTraits")))
            headers.append(.init(name: ":content-type", value: .string("application/json")))
            payload = try encoder.encode(value)
        case .messagewithunboundpayloadtraits(let value):
            headers.append(.init(name: ":event-type", value: .string("MessageWithUnboundPayloadTraits")))
            if let headerValue = value.header {
                headers.append(.init(name: "header", value: .string(headerValue)))
            }
            headers.append(.init(name: ":content-type", value: .string("application/json")))
            payload = try encoder.encode(value)
        case .sdkUnknown(_):
            throw ClientRuntime.ClientError.serializationFailed("cannot serialize the unknown event type!")
        }
        return ClientRuntime.EventStream.Message(headers: headers, payload: payload ?? .init())
    }
}
            """.trimIndent()

        contents.shouldContainOnlyOnce(expectedContents)
    }

    @Test
    fun `002 XmlUnionShape should be marked as indirect`() {
        val context = setupTests("Isolated/Restxml/xml-unions.smithy", "aws.protocoltests.restxml#RestXml")
        val contents = getFileContents(context.manifest, "/RestXml/models/XmlUnionShape.swift")
        val expectedContents =
            """
            extension ExampleClientTypes {
                public indirect enum XmlUnionShape: Swift.Equatable {
                    case doublevalue(Swift.Double)
                    case datavalue(ClientRuntime.Data)
                    case unionvalue(ExampleClientTypes.XmlUnionShape)
                    case structvalue(ExampleClientTypes.XmlNestedUnionStruct)
                    case mapvalue([Swift.String:Swift.String])
                    case stringlist([Swift.String])
                    case timestampvalue(ClientRuntime.Date)
                    case sdkUnknown(Swift.String)
                }
            
            }
            """.trimIndent()

        contents.shouldContainOnlyOnce(expectedContents)
    }

    private fun setupTests(smithyFile: String, serviceShapeId: String): TestContext {
        val context = TestContext.initContextFrom(smithyFile, serviceShapeId, MockHttpRestXMLProtocolGenerator()) { model ->
            model.defaultSettings(serviceShapeId, "RestXml", "2019-12-16", "Rest Xml Protocol")
        }
        context.generator.generateCodableConformanceForNestedTypes(context.generationCtx)
        context.generator.generateSerializers(context.generationCtx)
        context.generationCtx.delegator.flushWriters()
        return context
    }
}
