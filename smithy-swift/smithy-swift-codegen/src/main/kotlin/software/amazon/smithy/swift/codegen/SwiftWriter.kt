/*
 * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 *
 *  http://aws.amazon.com/apache2.0
 *
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

package software.amazon.smithy.swift.codegen

import java.util.function.BiFunction
import software.amazon.smithy.codegen.core.CodegenException
import software.amazon.smithy.codegen.core.Symbol
import software.amazon.smithy.codegen.core.SymbolDependency
import software.amazon.smithy.codegen.core.SymbolDependencyContainer
import software.amazon.smithy.codegen.core.SymbolReference
import software.amazon.smithy.model.Model
import software.amazon.smithy.model.shapes.MemberShape
import software.amazon.smithy.model.shapes.Shape
import software.amazon.smithy.model.traits.DocumentationTrait
import software.amazon.smithy.model.traits.EnumDefinition
import software.amazon.smithy.utils.CodeWriter

class SwiftWriter(private val fullPackageName: String) : CodeWriter() {
    init {
        trimBlankLines()
        trimTrailingSpaces()
        setIndentText("    ")
        // type with default set
        putFormatter('D', SwiftSymbolFormatter(setDefault = true))
        putFormatter('T', SwiftSymbolFormatter())
    }

    internal val imports: ImportDeclarations = ImportDeclarations()
    internal val dependencies: MutableList<SymbolDependency> = mutableListOf()

    companion object {
        val staticHeader: String = "// Code generated by smithy-swift-codegen. DO NOT EDIT!\n\n"
    }

    fun addImport(symbol: Symbol) {

        // always add dependencies
        dependencies.addAll(symbol.dependencies)

        // only add imports for symbols that exist in a certain namespace
        if (symbol.namespace.isNotEmpty()) {
            imports.addImport(symbol.namespace)
        }
    }

    fun addImport(packageName: String) {
        imports.addImport(packageName)
    }

    fun addImportReferences(symbol: Symbol, vararg options: SymbolReference.ContextOption) {
        symbol.references.forEach { reference ->
            for (option in options) {
                if (reference.hasOption(option)) {
                    addImport(reference.symbol)
                    break
                }
            }
        }
    }

    /**
     * Adds one or more dependencies to the generated code.
     *
     *
     * The dependencies of all writers created by the [SwiftDelegator]
     * are merged together to eventually generate a podspec file.
     *
     * @param dependencies Swift dependency to add.
     * @return Returns the writer.
     */
    fun addDependency(dependencies: SymbolDependencyContainer): SwiftWriter? {
        this.dependencies.addAll(dependencies.dependencies)
        return this
    }

    override fun toString(): String {
        val contents = super.toString()
        val imports = "${imports}\n\n"
        return staticHeader + imports + contents
    }

    /**
     * Implements Swift symbol formatting for the `$T` formatter
     */
    private class SwiftSymbolFormatter(val setDefault: Boolean = false) : BiFunction<Any, String, String> {
        override fun apply(type: Any, indent: String): String {
            when (type) {
                is Symbol -> {
                    var formatted = type.name
                    if (type.isBoxed()) {
                        formatted += "?"
                    }

                    val defaultValue = type.defaultValue()
                    if (defaultValue != null && setDefault) {
                        formatted += " = $defaultValue"
                    }
                    return formatted
                }
//            is SymbolReference -> println("symbol ref")
                else -> throw CodegenException("Invalid type provided for \$T. Expected a Symbol, but found `$type`")
            }
        }
    }

    /**
     * Configures the writer with the appropriate opening/closing multi-line doc comments and calls the [block]
     * with this writer. Any calls to `write()` inside of block will be escaped appropriately.
     * On return the writer's original state is restored.
     *
     * e.g.
     * ```
     * writer.writeMultiLineDocs() {
     *     write("This is a multi-line \n doc comment")
     * }
     * ```
     *
     * would output
     *
     * ```
     * /**
     *  This is a multi-line
     *  doc comment
     *  */
     * ```
     */
    fun writeMultiLineDocs(block: SwiftWriter.() -> Unit) {
        pushState("multiLineDocs")
        write("/**")
        setNewlinePrefix(" ")
        block(this)
        popState()
        write(" */")
    }

    /**
     * Configures the writer with the appropriate single-line doc comment and calls the [block]
     * with this writer. Any calls to `write()` inside of block will be escaped appropriately.
     * On return the writer's original state is restored.
     *
     * e.g.
     * ```
     * writer.writeSingleLineDocs() {
     *     write("This is a single-line doc comment")
     * }
     * ```
     *
     * would output
     *
     * ```
     * /// This is a single-line doc comment
     * ```
     */
    fun writeSingleLineDocs(block: SwiftWriter.() -> Unit) {
        pushState("singleLineDocs")
        setNewlinePrefix("/// ")
        block(this)
        popState()
    }

    /**
     * Writes documentation comments from a doc string.
     */
    fun writeDocs(docs: String) {
        if (docs.contains("\n")) {
            writeMultiLineDocs {
                write(sanitizeDocumentation(docs))
            }
        } else {
            writeSingleLineDocs {
                write(sanitizeDocumentation(docs))
            }
        }
    }

    /**
     * This function escapes "$" characters so formatters are not run.
     */
    private fun sanitizeDocumentation(doc: String): String {
        return doc.replace("\$", "\$\$")
    }

    /**
     * Writes shape documentation comments if docs are present.
     */
    fun writeShapeDocs(shape: Shape) {
        shape.getTrait(DocumentationTrait::class.java).ifPresent {
            writeDocs(it.value)
        }
    }

    /**
     * Writes member shape documentation comments if docs are present.
     */
    fun writeMemberDocs(model: Model, member: MemberShape) {
        if (member.getTrait(DocumentationTrait::class.java).isPresent) {
            writeDocs(member.getTrait(DocumentationTrait::class.java).get().value)
        } else if (member.getMemberTrait(model, DocumentationTrait::class.java).isPresent) {
            writeDocs(member.getMemberTrait(model, DocumentationTrait::class.java).get().value)
        }
    }

    /**
     * Writes documentation comments for Enum Definitions if present.
     */
    fun writeEnumDefinitionDocs(enumDefinition: EnumDefinition) {
        enumDefinition.documentation.ifPresent {
            writeDocs(it)
        }
    }
}
